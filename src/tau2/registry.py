import importlib
import json
from pathlib import Path
from typing import Callable, Dict, Optional

from loguru import logger
from pydantic import BaseModel

from tau2.agent.discrete_time_audio_native_agent import (
    create_discrete_time_audio_native_agent,
)
from tau2.agent.llm_agent import (
    LLMGTAgent,
    LLMSoloAgent,
    create_llm_agent,
    create_llm_gt_agent,
    create_llm_solo_agent,
)
from tau2.data_model.tasks import Task
from tau2.domains.airline.environment import (
    get_environment as airline_domain_get_environment,
)
from tau2.domains.airline.environment import get_tasks as airline_domain_get_tasks
from tau2.domains.airline.environment import (
    get_tasks_split as airline_domain_get_tasks_split,
)
from tau2.domains.mock.environment import get_environment as mock_domain_get_environment
from tau2.domains.mock.environment import get_tasks as mock_domain_get_tasks
from tau2.domains.retail.environment import (
    get_environment as retail_domain_get_environment,
)
from tau2.domains.retail.environment import get_tasks as retail_domain_get_tasks
from tau2.domains.retail.environment import (
    get_tasks_split as retail_domain_get_tasks_split,
)
from tau2.domains.telecom.environment import (
    get_environment_manual_policy as telecom_domain_get_environment_manual_policy,
)
from tau2.domains.telecom.environment import (
    get_environment_workflow_policy as telecom_domain_get_environment_workflow_policy,
)
from tau2.domains.telecom.environment import get_tasks as telecom_domain_get_tasks
from tau2.domains.telecom.environment import (
    get_tasks_full as telecom_domain_get_tasks_full,
)
from tau2.domains.telecom.environment import (
    get_tasks_small as telecom_domain_get_tasks_small,
)
from tau2.domains.telecom.environment import (
    get_tasks_split as telecom_domain_get_tasks_split,
)
from tau2.environment.environment import Environment
from tau2.user.user_simulator import DummyUser, UserSimulator
from tau2.user.user_simulator_base import FullDuplexUser, HalfDuplexUser
from tau2.user.user_simulator_streaming import VoiceStreamingUserSimulator


class RegistryInfo(BaseModel):
    """Options for the registry"""

    domains: list[str]
    agents: list[str]
    users: list[str]
    task_sets: list[str]


class Registry:
    """Registry for Users, Agents, and Domains"""

    def __init__(self):
        self._users: Dict[str, type] = {}  # HalfDuplexUser or FullDuplexUser
        self._agent_factories: Dict[str, Callable] = {}  # Factory functions for agents
        self._agent_task_filters: Dict[
            str, Callable[[Task], bool]
        ] = {}  # Optional task filters per agent
        self._agent_metadata: Dict[str, dict] = {}  # Optional metadata per agent
        self._domains: Dict[str, Callable[[], Environment]] = {}
        self._tasks: Dict[str, Callable[[Optional[str]], list[Task]]] = {}
        self._task_splits: Dict[str, Callable[[], dict[str, list[str]]]] = {}

    def register_user(
        self,
        user_constructor: type,
        name: Optional[str] = None,
    ):
        """Decorator to register a new User implementation (half-duplex or full-duplex)"""
        try:
            if not (
                issubclass(user_constructor, HalfDuplexUser)
                or issubclass(user_constructor, FullDuplexUser)
            ):
                raise TypeError(
                    f"{user_constructor.__name__} must implement HalfDuplexUser or FullDuplexUser"
                )
            key = name or user_constructor.__name__
            if key in self._users:
                raise ValueError(f"User {key} already registered")
            self._users[key] = user_constructor
        except Exception as e:
            logger.error(f"Error registering user {name}: {str(e)}")
            raise

    def register_agent_factory(
        self,
        factory: Callable,
        name: str,
        task_filter: Optional[Callable[[Task], bool]] = None,
        metadata: Optional[dict] = None,
    ):
        """Register an agent factory function.

        A factory function encapsulates agent construction logic, following
        the same pattern as domain factories (get_environment). The factory
        signature is: factory(tools, domain_policy, **kwargs) -> agent instance.

        Args:
            factory: A callable that creates an agent instance.
            name: The name to register the factory under.
            task_filter: Optional callable that takes a Task and returns True if
                the task is valid for this agent. Used by batch runners to filter
                tasks before building agents. If None, all tasks are accepted.
            metadata: Optional dict of agent metadata (e.g., {"solo_mode": True}).
                Retrieved via get_agent_metadata().
        """
        if name in self._agent_factories:
            raise ValueError(f"Agent factory {name} already registered")
        self._agent_factories[name] = factory
        if task_filter is not None:
            self._agent_task_filters[name] = task_filter
        if metadata is not None:
            self._agent_metadata[name] = metadata

    def get_agent_factory(self, name: str) -> Optional[Callable]:
        """Get a registered agent factory by name.

        Returns None if no factory is registered for the given name.

        Args:
            name: The name of the agent factory.

        Returns:
            The factory callable, or None if not found.
        """
        return self._agent_factories.get(name)

    def get_agent_task_filter(self, name: str) -> Optional[Callable[[Task], bool]]:
        """Get the task filter for a registered agent.

        Returns None if no task filter is registered for the given agent,
        meaning all tasks are accepted.

        Args:
            name: The name of the agent.

        Returns:
            A callable that takes a Task and returns True if valid, or None.
        """
        return self._agent_task_filters.get(name)

    def get_agent_metadata(self, name: str, key: str, default=None):
        """Get a metadata value for a registered agent.

        Args:
            name: The name of the agent.
            key: The metadata key to look up.
            default: Value to return if the key is not found.

        Returns:
            The metadata value, or default if not found.
        """
        agent_meta = self._agent_metadata.get(name, {})
        return agent_meta.get(key, default)

    def register_domain(
        self,
        get_environment: Callable[[], Environment],
        name: str,
    ):
        """Register a new Domain implementation"""
        try:
            if name in self._domains:
                raise ValueError(f"Domain {name} already registered")
            self._domains[name] = get_environment
        except Exception as e:
            logger.error(f"Error registering domain {name}: {str(e)}")
            raise

    def register_tasks(
        self,
        get_tasks: Callable[[Optional[str]], list[Task]],
        name: str,
        get_task_splits: Optional[Callable[[], dict[str, list[str]]]] = None,
    ):
        """Register a new Domain implementation.
        Args:
            get_tasks: A function that returns a list of tasks for the domain. If a task split name is provided, it returns the tasks for that split.
            name: The name of the domain.
            get_task_splits: A function that returns a dictionary of task splits for the domain.
        """
        try:
            if name in self._tasks:
                raise ValueError(f"Tasks {name} already registered")
            self._tasks[name] = get_tasks
            if get_task_splits is not None:
                self._task_splits[name] = get_task_splits
        except Exception as e:
            logger.error(f"Error registering tasks {name}: {str(e)}")
            raise

    def get_user_constructor(self, name: str) -> type:
        """Get a registered User implementation by name (half-duplex or full-duplex)"""
        if name not in self._users:
            raise KeyError(f"User {name} not found in registry")
        return self._users[name]

    def get_env_constructor(self, name: str) -> Callable[[], Environment]:
        """Get a registered Domain by name"""
        if name not in self._domains:
            raise KeyError(f"Domain {name} not found in registry")
        return self._domains[name]

    def get_tasks_loader(self, name: str) -> Callable[[Optional[str]], list[Task]]:
        """Get a registered Task Set by name.
        Args:
            name: The name of the task set.
        Returns:
            A function that takes an optional task_split_name parameter and returns the corresponding tasks.
            Can be called as: func() or func(task_split_name="base") or func("base").
        """
        if name not in self._tasks:
            raise KeyError(f"Task Set {name} not found in registry")
        return self._tasks[name]

    def get_task_splits_loader(
        self, name: str
    ) -> Optional[Callable[[], dict[str, list[str]]]]:
        """Get a registered task split dict loader."""
        if name not in self._task_splits:
            return None
        return self._task_splits[name]

    def get_users(self) -> list[str]:
        """Get all registered Users"""
        return list(self._users.keys())

    def get_agents(self) -> list[str]:
        """Get all registered Agents"""
        return list(self._agent_factories.keys())

    def get_domains(self) -> list[str]:
        """Get all registered Domains"""
        return list(self._domains.keys())

    def get_task_sets(self) -> list[str]:
        """Get all registered Task Sets"""
        return list(self._tasks.keys())

    def get_info(self) -> RegistryInfo:
        """
        Returns information about the registry.
        """
        try:
            info = RegistryInfo(
                users=self.get_users(),
                agents=self.get_agents(),
                domains=self.get_domains(),
                task_sets=self.get_task_sets(),
            )
            return info
        except Exception as e:
            logger.error(f"Error getting registry info: {str(e)}")
            raise


# Create a global registry instance
try:
    registry = Registry()
    logger.debug("Registering default components...")
    # User implementations
    registry.register_user(UserSimulator, "user_simulator")
    registry.register_user(DummyUser, "dummy_user")
    registry.register_user(
        VoiceStreamingUserSimulator, "voice_streaming_user_simulator"
    )

    # Agent factories
    registry.register_agent_factory(create_llm_agent, "llm_agent")
    registry.register_agent_factory(
        create_llm_gt_agent,
        "llm_agent_gt",
        task_filter=LLMGTAgent.check_valid_task,
    )
    registry.register_agent_factory(
        create_llm_solo_agent,
        "llm_agent_solo",
        task_filter=LLMSoloAgent.check_valid_task,
        metadata={"solo_mode": True},
    )
    registry.register_agent_factory(
        create_discrete_time_audio_native_agent,
        "discrete_time_audio_native_agent",
    )
    registry.register_domain(mock_domain_get_environment, "mock")
    registry.register_tasks(mock_domain_get_tasks, "mock")

    registry.register_domain(airline_domain_get_environment, "airline")
    registry.register_tasks(
        airline_domain_get_tasks,
        "airline",
        get_task_splits=airline_domain_get_tasks_split,
    )

    registry.register_domain(retail_domain_get_environment, "retail")
    registry.register_tasks(
        retail_domain_get_tasks,
        "retail",
        get_task_splits=retail_domain_get_tasks_split,
    )

    registry.register_domain(telecom_domain_get_environment_manual_policy, "telecom")
    registry.register_domain(
        telecom_domain_get_environment_workflow_policy, "telecom-workflow"
    )
    registry.register_tasks(telecom_domain_get_tasks_full, "telecom_full")
    registry.register_tasks(telecom_domain_get_tasks_small, "telecom_small")
    registry.register_tasks(
        telecom_domain_get_tasks,
        "telecom",
        get_task_splits=telecom_domain_get_tasks_split,
    )
    registry.register_tasks(
        telecom_domain_get_tasks,
        "telecom-workflow",
        get_task_splits=telecom_domain_get_tasks_split,
    )

    logger.debug(
        f"Default components registered successfully. Registry info: {json.dumps(registry.get_info().model_dump(), indent=2)}"
    )

    # Auto-discover experimental domains from experiments/domains/
    def discover_experimental_domains(reg: Registry) -> None:
        """
        Auto-discover and register domains from experiments/domains/.

        Scans the experiments/domains/ directory for valid domain implementations
        and registers them automatically. A valid domain must have:
        - A domain/ subdirectory with __init__.py
        - get_environment and get_tasks functions exported from domain/__init__.py

        If a domain exports ENVIRONMENT_VARIANTS dict, each variant is also
        registered as a separate domain (e.g., experimental:domain_m01).

        Failed registrations are logged as warnings but don't prevent other domains
        from being registered.
        """
        # Path to experiments/domains/ relative to this file
        experiments_domains_dir = (
            Path(__file__).parent.parent / "experiments" / "domains"
        )

        if not experiments_domains_dir.exists():
            logger.debug(
                "No experiments/domains/ directory found, skipping auto-discovery"
            )
            return

        for domain_dir in experiments_domains_dir.iterdir():
            if not domain_dir.is_dir():
                continue
            if domain_dir.name.startswith("_"):
                continue  # Skip __pycache__ and similar

            domain_init = domain_dir / "domain" / "__init__.py"
            if not domain_init.exists():
                continue  # Not a valid domain structure

            folder_name = domain_dir.name
            module_path = f"experiments.domains.{folder_name}.domain"
            # Prefix with "experimental:" to clearly distinguish from core domains
            registered_name = f"experimental:{folder_name}"

            try:
                module = importlib.import_module(module_path)

                # Check for required functions
                if not hasattr(module, "get_environment"):
                    logger.warning(
                        f"Experimental domain '{folder_name}' missing get_environment, skipping"
                    )
                    continue
                if not hasattr(module, "get_tasks"):
                    logger.warning(
                        f"Experimental domain '{folder_name}' missing get_tasks, skipping"
                    )
                    continue

                # Register the base domain with experimental: prefix
                reg.register_domain(module.get_environment, registered_name)

                # Register tasks (with optional task splits)
                get_task_splits = getattr(module, "get_tasks_split", None)
                reg.register_tasks(
                    module.get_tasks,
                    registered_name,
                    get_task_splits=get_task_splits,
                )

                logger.info(f"Registered experimental domain: {registered_name}")

                # Register environment variants if available
                if hasattr(module, "ENVIRONMENT_VARIANTS"):
                    variants = module.ENVIRONMENT_VARIANTS
                    for variant_name, variant_factory in variants.items():
                        if variant_name == "base":
                            continue  # Already registered as the main domain
                        variant_registered_name = f"{registered_name}:{variant_name}"
                        try:
                            reg.register_domain(
                                variant_factory, variant_registered_name
                            )
                            # Variants share the same tasks as the base domain
                            reg.register_tasks(
                                module.get_tasks,
                                variant_registered_name,
                                get_task_splits=get_task_splits,
                            )
                            logger.info(
                                f"Registered experimental domain variant: {variant_registered_name}"
                            )
                        except Exception as ve:
                            logger.warning(
                                f"Failed to register variant '{variant_registered_name}': {ve}"
                            )

            except Exception as e:
                logger.warning(
                    f"Failed to register experimental domain '{folder_name}': {e}"
                )

    # Run auto-discovery
    discover_experimental_domains(registry)

    logger.debug(
        f"Final registry info (including experimental): {json.dumps(registry.get_info().model_dump(), indent=2)}"
    )

except Exception as e:
    logger.error(f"Error initializing registry: {str(e)}")
